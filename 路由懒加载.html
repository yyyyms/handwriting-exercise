<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width= , initial-scale=1.0">
    <title>图片懒加载</title>
</head>
<body>
    <div id="test" style="margin-top: 1000px;">图片</div>
    <script>
        //scroll 监听与用户滚动行为相关的scroll
        //在scroll 事件处理程序中利用 Element.getBoundingClientRect() 方法判断目标元素与视口的交叉状态
        //当目标元素与视口的交叉状态大于0时，将真实的图片链接赋给目标元素 src 属性或者 backgroundImage 属性。
        //判断元素是否出现在视口区域内

        function isElementInViewport(el) {
            const {top,height,left,width} = el.getBoundingClientRect()
            const w = window.innerWidth || document.documentElement.clientWidth
            const h = window.innerHeight || document.documentElement.clientHeight
            return (top <= h && (top + height)>= 0 && left <= w && (left + width)>= 0)
        }
        window.addEventListener('scroll',cb,false)
        function cb(){
            let dom = document.querySelector('#test')
            
            if(isElementInViewport(dom)){
                // console.log('出现了');
                //todo
            }
        }
        // IntersectionObserver 接口，
        // 它可以异步监听目标元素与其祖先或视窗的交叉状态，
        // 注意这个接口是异步的，它不随着目标元素的滚动同步触发，
        // 所以它并不会影响页面的滚动性能。
        //IntersectionObserver(root,rootMargin,threshold)
        //root：所监听对象的具体祖先元素，默认是 viewport;
        // rootMargin：计算交叉状态时，将 margin 附加到祖先元素上，从而有效的扩大或者缩小祖先元素判定区域；
        //threshold：设置一系列的阈值，当交叉状态达到阈值时，会触发回调函数。
        
    </script>
</body>
</html>